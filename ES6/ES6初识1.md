# let和const
1. let和const声明在指定作用域之外的作用域无法访问的变量
2. let和const声明不会像var那样进行变量的提升
3. let和const不能够同一作用域中重复声明变量
4. const声明的常量，一旦设定后，不可以修改其绑定，但是可以修改它的值，也就是说const声明的常量必须进行初始化。当const声明的是一个对象时，它的值
可以修改，但是绑定不能修改
```
const obj ={
  a:1,
  b:2,
  c:"string"
}
//不能修改它的绑定
obj = {
  d:"new"
}//报错

//但是可以修改它的值
obj.a = "hh"
```
5. 暂时性死区，在一个作用域中，不能在let和const声明变量之前去使用该变量
6. 循环中的函数，对于forin也一样
```
var arr = [];
for(var i=0;i<10;i++){
    arr.push(function(){
        console.log(i)
    })
}

//创建i的副本
for(var i =0;i<10;i++){
    arr.push((function(value){
        return function(){
            console.log(value);
        }
    }(i)))
}
arr.forEach(function(fun){
    fun()
}) 
```
7. 当在循环中使用const时，会在第一次循环后报错，因为每次循环都会尝试修改它的值，但是在forin中却可以使用const声明，因为在forin循环中不是去修
改值，而是创建一个新绑定
8. 当使用var在全局作用域中声明一个全局变量时，该变量会成为全局对象的一个属性，这可能会导致无意中覆盖全局对象的某个属性，而使用let和const则不
会成为全局对象的一个属性

# 字符串
includes()方法：用来检测字符串是否包含指定文本
```
const str = "myString";
console.log(str.includes("my")); //true
console.log(str.includes("mS")); //false
```
startsWith()方法：在字符串的开始位置检测指定文本
```
const url = "https://www.github.com/webQian/MyBlog.git";
console.log(url.startsWith("https:/")); //true
console.log(url.startsWith("git")); //false
```
endsWith()方法：在字符串的结束位置检测指定文本
```
const myBlog = "https://www.github.com/webQian/MyBlog.git";
console.log(myBlog.endsWith("g.git")); //true
console.log(myBlog.endsWith("MyBlog")); //false
```
includes()、startsWith()、endsWith()都可以指定第二个参数，第二个参数指的是开始搜索位置的索引值，对于endsWith()来说，指定了第二个参数，则会从```索引值减去要搜索的文本的长度的结果```为位置开始正向匹配
```
endsWith("i",8); //从字符串的第7位开始搜索
```
repeat()方法：重复字符串

如果要查找某个字符或者子字符串在字符串中的位置，还是要使用indexOf()和lastIndexOf()方法，都会返回一个位置

# 模板字符串
基本语法
```
const str = `hh`;
```
在模板字符串中单引号和双引号不需要转义
```
const str = `"我是一句话"`;
console.log(str);
```
### 在ES6之前输出多行字符串的两种方法
1. 使用换行符
```
const olderStr = "我是一个 \n\
两行的字符串";
console.log(olderStr);
```
2. 使用数组拼接的方法
```
const arrStr = ["string","your","age"].join("\n");
console.log(arrStr);
```
有了模板字符串后可以直接使用回车，同时模板字符串中的缩进也属于字符串的一部分
```
const newStr = `this
   is
a
string`;
```

### 模板字符串的占位符
可以在模板字符串中使用表达式，如果使用了未定义的变量会抛出一个错误
```
const name = "xingkong";
console.log(`your name is ${name}`)
```
模板字符串中也可以嵌套模板字符串

### 标签模板字符串
可以在一个模板字符串前加入一个标签，那么会返回这个标签所对应的函数的返回值
```
let msg = foo`Hello`;
function foo(){
  return 1;
}
console.log(msg); //1
```
标签所对应的函数的参数：
第一个参数：模板字符串中的普通文本组成的数组，如果是以模板占位符开头或者结尾，会有一个空格字符
剩余的参数：由占位符的值组成的数组
```
const count = 10,
      price = 5;

let msg = foo`Hello ${count} my ${price}`;
function foo(string,...values){
  console.log(string); // ["Hello"," my ",""]
  console.log(values); //[10,5]
  //用函数模拟模板字符串的组成
  let result = "";
  for(let i=0;i<values.length;i++){
    result += string[i];
    result += values[i];
  }
  //普通文本数组比占位符数组多一位
  result += string[string.length-1];
  return result;
}
```

可以使用String.raw来查看转义前的字符串
```
let msg = `My\nString`;

let hello = String.raw`Hello\nWorld`;
console.log(msg);
console.log(hello);
```
标签函数的第一个参数有一个额外的属性raw，保存着模板字符串中的原始信息，也就是不转义的字符串，可以模拟实现String.raw()
```

const count = 10,
      price = 5;

let msg = foo`Hello\n ${count} my ${price}`;
function foo(string,...values){
  console.log(string); // ["Hello"," my ",""]
  console.log(values); //[10,5]
  //用函数模拟模板字符串的组成
  let result = "";
  for(let i=0;i<values.length;i++){
    result += string.raw[i];
    result += values[i];
  }
  //普通文本数组比占位符数组多一位
  result += string[string.length-1];
  return result;
}
console.log(msg) 
```

# 函数
